<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rover Control Panel</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />

    <!-- Leaflet Routing Machine CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />

    <!-- Leaflet Draw CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/0.4.2/leaflet.draw.css"/>

</head>
<body>
    <h1>Rover Control Panel</h1>
    
    <div class="container">
        <!-- Camera feed will take half of the container -->
        <div id="camera-feed" class="half">
            <img src="{{ url_for('video_feed') }}" alt="Video Stream">
        </div>
    
        <!-- Temperature and Map will take the other half -->
        <div class="half">
            <div id="map"></div>
        </div>
    </div>
    <p id="temperature">Loading...</p>
    <div>
        <label for="quality">Quality: </label>
        <input type="number" id="quality" value="10" min="0" max="100"/>
        <button id="getValueButton"onclick="getNumberFieldValue()">Get Value</button>
        <!-- Test Button for circle coords -->
        <!-- <button 
        onclick="generateCircleCoords(13.727114348838516, 100.77484935522082, 13.675710085331318, 100, 'circle' )">
            Generate Path
        </button> -->
        <button id="generateButton"
        onclick="
        if (currentLayerType == 'circle'){
            coordsList = generateCircleCoords(layer._latlng.lat, layer._latlng.lng, layer._mRadius, getNumberFieldValue())
        } else if(currentLayerType == 'polyline'){
            coordsList = layer._latlngs
        }
        console.log(coordsList);
        handleCoordsList(coordsList);
        ">
            Generate Path
        </button>
        <label for="drawPathSwitch">Enable Draw Path</label>
        <input type="checkbox" id="drawPathSwitch" />
    </div>

    <div class="control-panel">
        <!-- First row of buttons -->
        <button class="control-button" onclick="sendCommand('q')">
            <img src="{{ url_for('static', filename='img/rotateleft.png') }}" alt="Q" class="button-image">
        </button>
        <button class="control-button" onclick="sendCommand('w')">
            <img src="{{ url_for('static', filename='img/forward.png') }}" alt="W" class="button-image">
        </button>
        <button class="control-button" onclick="sendCommand('e')">
            <img src="{{ url_for('static', filename='img/rotateright.png') }}" alt="E" class="button-image">
        </button>
        <button class="control-button" onclick="sendCommand('r')">
            <img src="{{ url_for('static', filename='img/diagonalright.png') }}" alt="R" class="button-image">
        </button>
    
        <!-- Second row of buttons -->
        <button class="control-button" onclick="sendCommand('a')">
            <img src="{{ url_for('static', filename='img/crableft.png') }}" alt="A" class="button-image">
        </button>
        <button class="control-button" onclick="sendCommand('s')">
            <img src="{{ url_for('static', filename='img/reverse.png') }}" alt="S" class="button-image">
        </button>
        <button class="control-button" onclick="sendCommand('d')">
            <img src="{{ url_for('static', filename='img/crabright.png') }}" alt="D" class="button-image">
        </button>
        <button class="control-button" onclick="sendCommand('f')">
            <img src="{{ url_for('static', filename='img/diagonalleft.png') }}" alt="F" class="button-image">
        </button>
    
        <!-- Right side buttons -->
        <button class="control-button" onclick="sendCommand('u')">
            <img src="{{ url_for('static', filename='img/bigleft.png') }}" alt="U" class="button-image">
        </button>
        <button class="control-button" onclick="sendCommand('o')">
            <img src="{{ url_for('static', filename='img/bigright.png') }}" alt="O" class="button-image">
        </button>
        <button class="control-button" onclick="sendCommand('j')">
            <img src="{{ url_for('static', filename='img/smallleft.png') }}" alt="J" class="button-image">
        </button>
        <button class="control-button" onclick="sendCommand('k')">
            <img src="{{ url_for('static', filename='img/center.png') }}" alt="K" class="button-image">
        </button>
        <button class="control-button" onclick="sendCommand('l')">
            <img src="{{ url_for('static', filename='img/smallright.png') }}" alt="L" class="button-image">
        </button>
    
        <!-- STOP Button -->
        <button class="control-button stop-button" onclick="sendCommand('h')">
            <img src="{{ url_for('static', filename='img/stop.png') }}" alt="Stop" class="button-image">
            <span>STOP</span>
        </button>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>

    <!-- Leaflet Routing Machine JS -->
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>

    <!-- Leaflet Draw JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/0.4.2/leaflet.draw.js"></script>

    <!-- Initialize the map and routing -->
    <script>
        // Enable when drawPath is True
        let currentLayerType = null;
        let layer = null;

        let drawPath = false; // Initial value of drawPath

        // Get the switch element
        const drawPathSwitch = document.getElementById('drawPathSwitch');

        // Add an event listener to toggle between drawPath being true or false
        drawPathSwitch.addEventListener('change', function() {
            drawPath = this.checked; // Set drawPath to true if checked, false otherwise
            toggleDrawPath(); // Call function to toggle the functionality
        });

        // Set initial coordinates of the rover
        var roverCoords = [13.7271, 100.7747 ];  // This should be updated with actual rover coordinates

        var map = L.map('map').setView(roverCoords, 13); // Set initial view to rover's location

        var drawnFeatures = new L.FeatureGroup();
        map.addLayer(drawnFeatures);

        var drawControl = new L.Control.Draw({
            edit: {
                featureGroup: drawnFeatures,
                remove: true
            }
        });
        map.addControl(drawControl);

        // Function to toggle functionality based on drawPath value
        function toggleDrawPath() {
            if (drawPath) {
                console.log("Draw path enabled");
                enableDrawControl(); // Enable draw functionality
                disableClickControl(); // Disable click functionality
                enableInputs();
                drawnFeatures.clearLayers();
                if (routeControl) {
                    map.removeControl(routeControl); // Remove existing route if any
                }
            } else {
                console.log("Map click functionality enabled");
                disableDrawControl(); // Disable draw functionality
                enableClickControl(); // Enable click functionality
                disableInputs();
                drawnFeatures.clearLayers();
                if (routeControl) {
                    map.removeControl(routeControl); // Remove existing route if any
                }
            }
        }

        function getNumberFieldValue() {
            const numberField = document.getElementById('quality');
            const quality = parseInt(numberField.value, 10);  // Convert value to an integer
            return quality;
        }

        function generateCircleCoords(
            lat, 
            lng, 
            radius, // Radius in meters
            quality
        ) {
            console.log("Generating Coords");
            const coords = []; // Array to store coordinates
                const numPoints = Math.floor(quality * (radius / 100)); // Adjust points based on radius and quality

                // Step 1: Calculate initial points around the circle
                for (let i = 0; i < numPoints; i++) {
                    const angle = (2 * Math.PI / numPoints) * i; // Angle in radians

                    // Calculate new latitude and longitude using basic trigonometry
                    const newLat = lat + (radius / 111320) * Math.cos(angle);
                    const newLng = lng + (radius / (111320 * Math.cos(lat * Math.PI / 180))) * Math.sin(angle);

                    coords.push([newLat, newLng]); // Store the initial coordinate
                }

                // Step 2: Calculate the mean distance from the center
                let totalDistance = 0;
                coords.forEach(([lat2, lng2]) => {
                    const dist = euclideanDistance(lat, lng, lat2, lng2);
                    totalDistance += dist;
                });

                const meanDistance = totalDistance / numPoints; // Mean distance

                // Step 3: Adjust each coordinate to align with the desired radius
                const adjustedCoords = coords.map(([lat2, lng2]) => {
                    const dist = euclideanDistance(lat, lng, lat2, lng2);
                    const adjustment = radius / dist;

                    // Adjust the latitude and longitude proportionally
                    const adjustedLat = lat + (lat2 - lat) * adjustment;
                    const adjustedLng = lng + (lng2 - lng) * adjustment;

                    return [adjustedLat, adjustedLng];
                });

                console.log("Adjusted Coords:", adjustedCoords);
                return adjustedCoords;
        }

        // Helper function to calculate Euclidean distance between two points
        function euclideanDistance(lat1, lng1, lat2, lng2) {
            const dLat = (lat2 - lat1) * 111320; // Convert degrees to meters
            const dLng = (lng2 - lng1) * 111320 * Math.cos(lat1 * Math.PI / 180);
            return Math.sqrt(dLat ** 2 + dLng ** 2); // Pythagorean theorem
        }

        function handleCoordsList(coordsList){
            let lastCoord = null;
            let length = 0;
            resetCoords();

            coordsList.forEach(function(coord, index) {
                const currentCoord = {
                    i: index,
                    lat: parseFloat(coord.lat.toFixed(4)),  // Limit latitude to 4 decimal places
                    lng: parseFloat(coord.lng.toFixed(4))   // Limit longitude to 4 decimal places
                };

                // Check if current coordinate is different from the last sent coordinate
                if (!lastCoord || lastCoord.lat !== currentCoord.lat || lastCoord.lng !== currentCoord.lng) {
                    handleCoords(currentCoord.i, currentCoord.lat, currentCoord.lng);  // Send the coordinate if it's not a duplicate
                    length+=1;
                    console.log(`Coords sent!\nIndex: ${index}\nlat: ${currentCoord.lat}\nlong: ${currentCoord.lng}`);
                            
                    // Update the lastCoord to the current one after sending
                    lastCoord = currentCoord;   
                } else {
                    console.log(`Duplicate coordinate, not sent!\nIndex: ${index}\nlat: ${currentCoord.lat}\nlong: ${currentCoord.lng}`);
                }
            });
            console.log("Start sending coords to arduino");
            sendCoords(length);
        }

        function enableDrawControl(){
            map.on("draw:created", function (e) {
                currentLayerType = e.layerType;
                layer = e.layer;
                console.log(e);

                drawnFeatures.clearLayers();
                drawnFeatures.addLayer(layer);

                layer.bindPopup(`<p>${JSON.stringify(layer.toGeoJSON())}</p>`);
            });

            map.on("draw:edited", function(e){
                var layers = e.layers;
                var type = e.layerType;

                layers.eachLayer(function(layer){
                    console.log(layer);
                })

                if(layerType=='marker'){
                    //Do something
                }
            })

            map.on("draw:deleted", function (e) {
                var layers = e.layers;
                layers.eachLayer(function (layer) {
                    console.log('Deleted Layer:', layer);
                });
            });
        }
        
        function disableDrawControl() {
            map.off("draw:created"); // Disable draw:created event listener
            map.off("draw:edited");
            map.off("draw:deleted");
        }

        // Add OpenStreetMap tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Marker for the rover
        var roverMarker = L.marker(roverCoords).addTo(map).bindPopup("Rover is here").openPopup();

        var routeControl;

        // Enable map click functionality
        function enableClickControl() {
            map.on('click', function (e) {
                var destination = e.latlng;

                if (routeControl) {
                    map.removeControl(routeControl); // Remove existing route if any
                }

                // Create a new route
                routeControl = L.Routing.control({
                    waypoints: [
                        L.latLng(roverCoords), // Start at the rover's current position
                        L.latLng(destination)   // End at the clicked location
                    ],
                    routeWhileDragging: true
                }).on('routesfound', function (e) {
                    console.log("Route found:", e);
                    let lastCoord = null;
                    let length = 0;
                    resetCoords();

                    e.routes[0].coordinates.forEach(function (coord, index) {
                        const currentCoord = { i: index, lat: coord.lat, lng: coord.lng };
                        if (!lastCoord || lastCoord.lat !== currentCoord.lat || lastCoord.lng !== currentCoord.lng) {
                            handleCoords(currentCoord.i, currentCoord.lat, currentCoord.lng);
                            length++;
                            console.log(`Coords sent: \nIndex: ${index}, \nlat: ${currentCoord.lat}, \nlng: ${currentCoord.lng}`);

                            lastCoord = currentCoord;
                        } else {
                            console.log(`Duplicate coord, not sent: \nIndex: ${index}, \nlat: ${currentCoord.lat}, \nlng: ${currentCoord.lng}`);
                        }
                    });
                    console.log("Start sending coords to Arduino");
                    sendCoords(length);
                }).addTo(map);
            });
        }

        // Disable map click functionality
        function disableClickControl() {
            map.off('click'); // Disable the click event listener
        }

        function enableInputs() {
            document.getElementById('quality').disabled = false;
            document.getElementById('getValueButton').disabled = false;
            document.getElementById('generateButton').disabled = false;
        }

        // Function to disable the Quality input and Get Value button
        function disableInputs() {
            document.getElementById('quality').disabled = true;
            document.getElementById('getValueButton').disabled = true;
            document.getElementById('generateButton').disabled = true;
        }
    </script>

    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>
